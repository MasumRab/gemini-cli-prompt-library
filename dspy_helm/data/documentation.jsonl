{"input": "Write documentation for the `calculate_average` function that explains it takes a list of numbers and returns the arithmetic mean.", "expected_output": "def calculate_average(numbers: List[float]) -> float:\n    \"\"\"Calculate the arithmetic mean of a list of numbers.\n\n    Args:\n        numbers: A list of numeric values\n\n    Returns:\n        The average value, or 0 if the list is empty\n    \"\"\"\n    if not numbers:\n        return 0.0\n    return sum(numbers) / len(numbers)"}
{"input": "Write documentation for the `User` class that models a system user with name and email attributes.", "expected_output": "class User:\n    \"\"\"Represents a user in the system.\n\n    Attributes:\n        name: The user's display name\n        email: The user's email address\n    \"\"\"\n\n    def __init__(self, name: str, email: str):\n        self.name = name\n        self.email = email"}
{"input": "Write documentation for the `is_palindrome` function that checks if text reads the same forwards and backwards.", "expected_output": "def is_palindrome(text: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\n\n    Ignores case and non-alphanumeric characters.\n\n    Args:\n        text: The string to check\n\n    Returns:\n        True if the string is a palindrome, False otherwise\n    \"\"\"\n    cleaned = ''.join(c.lower() for c in text if c.isalnum())\n    return cleaned == cleaned[::-1]"}
{"input": "Write documentation for the `FileReader` class that provides methods to read file contents.", "expected_output": "class FileReader:\n    \"\"\"Reads and provides access to file contents.\n\n    Args:\n        path: Path to the file to read\n\n    Raises:\n        FileNotFoundError: If the file does not exist\n    \"\"\"\n\n    def __init__(self, path: str):\n        self.path = path\n        self._content: Optional[str] = None\n\n    def read(self) -> str:\n        \"\"\"Read and return the entire file contents.\"\"\"\n        with open(self.path, 'r') as f:\n            self._content = f.read()\n        return self._content"}
{"input": "Write documentation for the `validate_email` function that validates email address format using regex.", "expected_output": "import re\n\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate email address format.\n\n    Args:\n        email: The email address to validate\n\n    Returns:\n        True if the email format is valid, False otherwise\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))"}
{"input": "Write documentation for the `sort_list` function that sorts a list using quicksort algorithm.", "expected_output": "def sort_list(arr: List[int]) -> List[int]:\n    \"\"\"Sort a list of integers using quicksort.\n\n    Args:\n        arr: The list of integers to sort\n\n    Returns:\n        A new sorted list in ascending order\n    \"\"\"\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return sort_list(left) + middle + sort_list(right)"}
{"input": "Write documentation for the `Cache` class that provides in-memory caching with TTL support.", "expected_output": "from typing import Optional\nimport time\n\nclass Cache:\n    \"\"\"Simple in-memory cache with time-to-live support.\n\n    Attributes:\n        _store: Internal dictionary for cache storage\n        _ttl: Default time-to-live in seconds\n    \"\"\"\n\n    def __init__(self, ttl: int = 3600):\n        self._store = {}\n        self._ttl = ttl\n\n    def set(self, key: str, value: any, ttl: Optional[int] = None) -> None:\n        \"\"\"Store a value in the cache.\n\n        Args:\n            key: The cache key\n            value: The value to cache\n            ttl: Optional custom TTL in seconds\n        \"\"\"\n        self._store[key] = (value, time.time() + (ttl or self._ttl))\n\n    def get(self, key: str) -> Optional[any]:\n        \"\"\"Retrieve a value from the cache.\n\n        Args:\n            key: The cache key\n\n        Returns:\n            The cached value or None if not found/expired\n        \"\"\"\n        if key not in self._store:\n            return None\n        value, expiry = self._store[key]\n        if time.time() > expiry:\n            del self._store[key]\n            return None\n        return value"}
{"input": "Write documentation for the `uppercase_string` function that converts strings to uppercase with locale support.", "expected_output": "def uppercase_string(text: str) -> str:\n    \"\"\"Convert a string to uppercase.\n\n    Args:\n        text: The string to convert\n\n    Returns:\n        The uppercase version of the string\n    \"\"\"\n    return text.upper()"}
{"input": "Write documentation for the `Rectangle` class that represents a 2D rectangle with area and perimeter calculations.", "expected_output": "class Rectangle:\n    \"\"\"Represents a 2D rectangle shape.\n\n    Attributes:\n        width: The width of the rectangle\n        height: The height of the rectangle\n    \"\"\"\n\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n    def area(self) -> float:\n        \"\"\"Calculate the rectangle's area.\n\n        Returns:\n            The area (width × height)\n        \"\"\"\n        return self.width * self.height\n\n    def perimeter(self) -> float:\n        \"\"\"Calculate the rectangle's perimeter.\n\n        Returns:\n            The perimeter (2 × (width + height))\n        \"\"\"\n        return 2 * (self.width + self.height)"}
{"input": "Write documentation for the `retry_function` decorator that automatically retries failed function calls.", "expected_output": "import functools\nimport time\n\ndef retry_function(retries: int = 3, delay: float = 1.0):\n    \"\"\"Decorator that retries a function on failure.\n\n    Args:\n        retries: Maximum number of retry attempts\n        delay: Delay between retries in seconds\n\n    Returns:\n        Decorated function with retry logic\n    \"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(retries):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    if attempt < retries - 1:\n                        time.sleep(delay)\n            raise last_exception\n        return wrapper\n    return decorator"}
{"input": "Write documentation for the `parse_json` function that safely parses JSON strings with error handling.", "expected_output": "import json\nfrom typing import Any, Dict\n\ndef parse_json(json_string: str) -> Dict[str, Any]:\n    \"\"\"Parse a JSON string into a dictionary.\n\n    Args:\n        json_string: The JSON string to parse\n\n    Returns:\n        A dictionary representing the parsed JSON\n\n    Raises:\n        ValueError: If the JSON is invalid\n    \"\"\"\n    try:\n        return json.loads(json_string)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON: {e}\")"}
{"input": "Write documentation for the `BankAccount` class that models a bank account with deposit, withdraw, and balance check.", "expected_output": "class BankAccount:\n    \"\"\"Represents a bank account with basic operations.\n\n    Attributes:\n        balance: The current account balance\n    \"\"\"\n\n    def __init__(self, initial_balance: float = 0):\n        self.balance = initial_balance\n\n    def deposit(self, amount: float) -> None:\n        \"\"\"Deposit money into the account.\n\n        Args:\n            amount: The amount to deposit (must be positive)\n\n        Raises:\n            ValueError: If amount is negative\n        \"\"\"\n        if amount < 0:\n            raise ValueError(\"Deposit amount must be positive\")\n        self.balance += amount\n\n    def withdraw(self, amount: float) -> None:\n        \"\"\"Withdraw money from the account.\n\n        Args:\n            amount: The amount to withdraw (must be positive)\n\n        Raises:\n            ValueError: If amount exceeds balance\n        \"\"\"\n        if amount > self.balance:\n            raise ValueError(\"Insufficient funds\")\n        self.balance -= amount"}
{"input": "Write documentation for the `capitalize_words` function that capitalizes each word in a string.", "expected_output": "def capitalize_words(text: str) -> str:\n    \"\"\"Capitalize the first letter of each word.\n\n    Args:\n        text: The string to process\n\n    Returns:\n        The string with each word capitalized\n    \"\"\"\n    return ' '.join(word.capitalize() for word in text.split())"}
{"input": "Write documentation for the `find_max` function that finds the maximum value using a divide and conquer approach.", "expected_output": "from typing import List, Optional\n\ndef find_max(arr: List[int]) -> Optional[int]:\n    \"\"\"Find the maximum value in a list.\n\n    Args:\n        arr: The list of integers\n\n    Returns:\n        The maximum value, or None if list is empty\n    \"\"\"\n    if not arr:\n        return None\n    max_val = arr[0]\n    for num in arr:\n        if num > max_val:\n            max_val = num\n    return max_val"}
{"input": "Write documentation for the `RateLimiter` class that implements a sliding window rate limiter.", "expected_output": "from collections import deque\nimport time\n\nclass RateLimiter:\n    \"\"\"Implements a sliding window rate limiter.\n\n    Args:\n        max_requests: Maximum requests allowed per window\n        window: Time window in seconds\n    \"\"\"\n\n    def __init__(self, max_requests: int, window: int):\n        self.max_requests = max_requests\n        self.window = window\n        self.requests = deque()\n\n    def allow_request(self) -> bool:\n        \"\"\"Check if a request is allowed under the rate limit.\n\n        Returns:\n            True if request is allowed, False if rate limited\n        \"\"\"\n        now = time.time()\n        while self.requests and now - self.requests[0] > self.window:\n            self.requests.popleft()\n        if len(self.requests) < self.max_requests:\n            self.requests.append(now)\n            return True\n        return False"}
{"input": "Write documentation for the `escape_html` function that escapes HTML special characters to prevent XSS.", "expected_output": "import html\n\ndef escape_html(text: str) -> str:\n    \"\"\"Escape HTML special characters for safe display.\n\n    Converts: < → &lt;, > → &gt;, & → &amp;, \" → &quot;\n\n    Args:\n        text: The text to escape\n\n    Returns:\n        HTML-escaped text safe for rendering\n    \"\"\"\n    return html.escape(text)"}
{"input": "Write documentation for the `DatabaseConnection` class that manages database connections with pooling.", "expected_output": "from typing import Optional\n\nclass DatabaseConnection:\n    \"\"\"Manages a database connection with automatic cleanup.\n\n    Attributes:\n        connected: Whether the connection is active\n    \"\"\"\n\n    def __init__(self, host: str, port: int, database: str = \"\"):\n        self.host = host\n        self.port = port\n        self.database = database\n        self.connected = False\n        self._connection = None\n\n    def connect(self) -> bool:\n        \"\"\"Establish a database connection.\n\n        Returns:\n            True if connection successful\n        \"\"\"\n        # Simulated connection\n        self.connected = True\n        return True\n\n    def disconnect(self) -> None:\n        \"\"\"Close the database connection.\"\"\"\n        self.connected = False"}
{"input": "Write documentation for the `chunk_list` function that splits a list into evenly sized chunks.", "expected_output": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef chunk_list(arr: List[T], size: int) -> List[List[T]]:\n    \"\"\"Split a list into chunks of specified size.\n\n    Args:\n        arr: The list to chunk\n        size: The size of each chunk\n\n    Returns:\n        A list of chunks\n    \"\"\"\n    return [arr[i:i + size] for i in range(0, len(arr), size)]"}
{"input": "Write documentation for the `EventEmitter` class that implements the observer pattern for event handling.", "expected_output": "from typing import Dict, List, Callable, Any\n\nclass EventEmitter:\n    \"\"\"Implements the observer pattern for event handling.\n\n    Attributes:\n        _events: Dictionary mapping event names to handlers\n    \"\"\"\n\n    def __init__(self):\n        self._events: Dict[str, List[Callable]] = {}\n\n    def on(self, event: str, handler: Callable) -> None:\n        \"\"\"Register an event handler.\n\n        Args:\n            event: The event name\n            handler: The callback function\n        \"\"\"\n        if event not in self._events:\n            self._events[event] = []\n        self._events[event].append(handler)\n\n    def emit(self, event: str, *args: Any) -> None:\n        \"\"\"Emit an event, calling all registered handlers.\n\n        Args:\n            event: The event name\n            *args: Arguments to pass to handlers\n        \"\"\"\n        for handler in self._events.get(event, []):\n            handler(*args)"}
{"input": "Write documentation for the `generate_uuid` function that generates UUID v4 compliant strings.", "expected_output": "import uuid\n\ndef generate_uuid() -> str:\n    \"\"\"Generate a UUID v4 string.\n\n    Returns:\n        A random UUID in the standard format\n    \"\"\"\n    return str(uuid.uuid4())"}
